<!DOCTYPE html>
<html>

<head>
  <title>Intersection Observer</title>
  <meta charset='utf-8'>
  <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
  <script class='remove'>
  var respecConfig = {
    shortName: "intersection-observer",
    specStatus: "ED",
    edDraftURI: "https://github.com/slightlyoff/IntersectionObserver/",
    // publishDate: "2015-09-01",
    editors: [{
      name: "Michael Blain",
      mailto: "mpb@google.com",
      company: "Google",
      companyURL: "https://www.google.com/",
    },],
    wg: "Web Performance Working Group",
    wgURI: "http://www.w3.org/2010/webperf/",
    wgPublicList: "public-web-perf",
    subjectPrefix: "[Intersection Observer]",
    format: "markdown",
    otherLinks: [{
      key: 'Repository',
      data: [{
        value: 'We are on GitHub',
        href: 'https://github.com/slightlyoff/IntersectionObserver/'
      }, {
        value: 'Commit history',
        href: 'https://github.com/slightlyoff/IntersectionObserver/commits/master/index.html'
      }, {
        value: 'File a bug',
        href: 'https://github.com/slightlyoff/IntersectionObserver/issues'
      }]
    }],
    wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/45211/status"
  };
  </script>
</head>

<body>
  <section id='abstract'>
    <p>This specification describes  an API that can be used to understand the visibility and position of DOM elements relative to a viewport. The position is delivered asynchronously and is useful for understanding the visibility of elements and implementing pre-loading and deferred loading of DOM content.</p>
  </section>

  <section id='sotd'>
    <p>This is a <strong>work in progress</strong> and may change without any notices.</p>
  </section>

  <section class='informative'>
    <h2>Introduction</h2>
    <p>The web's traditional position calculation mechanisms rely on explicit queries of DOM state that are known to cause (expensive) style recalcuation and layout and, frequently, are a source of significant performance overhead due to continuous polling for this information.</p>

    <p>A body of common practice has evolved that relies on these behaviors, however, including (but not limited to):
      <ul>
        <li>Building custom pre- and deferred-loading of DOM and data.</li>
        <li>Implementing data-bound high-performance scrolling lists which load and render subsets of data sets. These lists are a central mobile interaction idiom.</li>
        <li>Calculating element visibility. In particular, [ad networks now require reporting of ad "visibility" for monetizing impressions](http://www.iab.net/iablog/2014/03/viewability-has-arrived-what-you-need-to-know-to-see-through-this-sea-change.html). This has led to many sites abusing scroll handlers (causing jank on scroll), [synchronous layout invoking readbacks](http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html) (causing unneccessary critical work in rAF loops), and resorting to exotic plugin-based solutions for computing "true" element visibility (with all the associated overhead of the plugin architecture).</li>
      </ul>
    </p>
    <p>These use-cases have several common properties:
      <ol>
        <li>They can be represented as passive "queries" about the state of individual elements with respect to some other element (or the global viewport)</li>
        <li>They do not impose hard latency requirements; that is to say, the information can be delivered asynchronously (e.g. from another thread) without penalty</li>
        <li>They are poorly supported by nearly all combinations of existing web platform features, requiring extraordinary developer effort despite their widespread use.</li>
      </ol>
    </p>
    <p>A notable non-goal is pixel-accurate information about what was actually displayed (which can be quite difficult to obtain efficiently in certain browser architectures in the face of filters, webgl, and other features). In all of these scenarios the information is useful even when delivered at a slight delay and without perfect compositing-result data.</p>

    <p>The Intersersection Observer API addresses the above issues by giving developers a new method to asynchronously query the position of an element with respect to other elements or the global viewport. The asynchronous delivery eliminates the need for costly DOM and style queries, continuous polling, and use of custom plugins. By removing the need for these methods it allows applications to significantly reduce their CPU, GPU and energy costs.</p>

    <pre class="highlight example">
      var observer = new IntersectionObserver(function(changes) {
        for (var i in changes) {
          console.log(changes[i].time);               // Timestamp when the change occurred
          console.log(changes[i].rootBounds);         // Unclipped area of _root_
          console.log(changes[i].intersectionRect);   // Unclipped area of _target_ intersected with _rootBounds_
          console.log(changes[i].boundingClientRect); // _target.boundingClientRect()_
          console.log(changes[i].target);             // the Element _target_
        }
      }, {});

      // Watch all threshold events on a specific descendant of the viewport
      observer.observe(childElement);

      observer.disconnect(); // removes all
    </pre>
  </section>

  <section>
    <h2>Intersection Observer</h2>

    <p>The <a>Intersection Observer</a> API enables developers to understand the visibility and position of DOM elements relative to a root element or the top level document's viewport.</p>

    <section>
      <h2>The <dfn>IntersectionObserverCallback</dfn></h2>
      <dl title='callback IntersectionObserverCallback = void (IntersectionObserverEntryList entries, IntersectionObserver observer)' class='idl'></dl>
      <p>This callback will be invoked when there are changes to <i>target</i>'s intersection with _root_, as per the <a>processing model</a>.</p>
    </section>

    <section>
      <h2>The <dfn>Intersection Observer</dfn> interface</h2>

      <p>The <a>IntersectionObserver</a> interface can be used to observe changes in the intersection of a _target_ <a href="http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Element.html">Element</a> and a _root_ <a href="http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Element.html">Element</a> (or the top-level document's viewport). </p>
      <p>A <dfn>registered intersection observer</dfn> consists of an observer (an <a>IntersectionObserver</a> object) and options (a <a>IntersectionObserverInit</a> dictionary).</p>

      <dl title='[Constructor(IntersectionObserverCallback callback, IntersectionObserverInit options), Exposed=(Window,Worker)] interface IntersectionObserver' class='idl'>

        <dt>void observe(Element target)</dt>
        <dd>
          <ol>
            <li>If _target_ is in _this_.<a>observationTargets</a>, return.</li>
            <li>If _target_ is NOT a descendent of _this_.<a>init</a>.<a href="#widl-IntersectionObserverInit-root" class="internalDFN">root</a>, throw a TypeError.</li>
            <li>Add _this_ to _target_.<a>registeredObservers</a>.</li>
            <li>Add _target_ to _this_.<a>observationTargets</a>.</li>
          </ol>
        </dd>
        <dt>void unobserve(Element target)</dt>
        <dd>
          <ol>
            <li>Remove the <a>registered intersection observer</a> from _target_.<a>registeredObservers</a></li>
          </ol>
        </dd>
        <dt>void disconnect()</dt>
        <dd>For each _target_ in _this_.<a>observationTargets</a>
          <ol>
            <li>Remove the <a>registered intersection observer</a> from _target_.<a>registeredObservers</a></li>
          </ol>
        </dd>
        <dt>IntersectionObserverEntryList takeRecords()</dt>
        <dd>
          <ol>
            <li>Construct an <a>IntersectionObserverEntryList</a> from _this_.<a>queuedEntries</a>.</li>
            <li>Clear _this_.<a>queuedEntries</a>.</li>
            <li>Return the <a>IntersectionObserverEntryList</a>.</li>
          </ol>
        </dd>
      </dl>

    </section>

    <section>
      <h2>The <dfn>IntersectionObserverEntryList</dfn> typedef</h2>
      <dl class='idl' title='typedef sequence<IntersectionObserverEntry> IntersectionObserverEntryList'></dl>
    </section>

    <section>
      <h2>The <dfn>IntersectionObserverEntry</dfn> interface</h2>
      <dl class='idl' title='interface IntersectionObserverEntry'>
        <dt>readonly attribute DOMHighResTimeStamp time</dt>
        <dd>The attribute MUST return a <a href="https://w3c.github.io/hr-time/#dom-domhighrestimestamp">DOMHighResTimeStamp</a> that corresponds to the time the intersection was recorded.</dd>
        <dt>readonly attribute DOMRect rootBounds</dt>
        <dd>The visible dimensions of _root_, in the coordinate space of the document the root element is in. If _root_ is undefined then use the coordinate space of the top-level document.</dd>
        <dt>readonly attribute DOMRect boundingClientRect</dt>
        <dd>The <a href="http://www.w3.org/TR/2014/WD-geometry-1-20140522/#DOMRect">DOMRect</a> corresponding to the _target_'s <a href="http://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect</a>.</dd>
        <dt>readonly attribute DOMRect intersectionRect</dt>
        <dd>The <a href="http://www.w3.org/TR/2014/WD-geometry-1-20140522/#DOMRect">DOMRect</a> corresponding to _boundingClientRect_ intersected by each of <i>target</i>'s ancestors' clip rects (up to but not including _root_), intersected with _rootBounds_. This value represents the portion of _target_ actually visible within _rootBounds_.
        <dt>readonly attribute Element target</dt>
        <dd>The _element_ whose intersection with _root_ changed.</dd>
      </dl>
    </section>

    <section>
      <h2><dfn>IntersectionObserverInit</dfn></h2>
      <dl title='dictionary IntersectionObserverInit' class='idl'>
        <dt>Element? root = null</dt>
        <dd>The _root_ to use for intersection. If not provided, use the top-level document's viewport.</dd>
        <dt>DOMString rootMargin = "0px"</dt>
        <dd>
          Same as <a href="http://www.w3.org/TR/CSS21/box.html#margin-properties">margin</a>, can be 1, 2, 3 or 4 components, possibly negative lengths.
          <p> If there is only one component value, it applies to all sides. If there are two values, the top and bottom margins are set to the first value and the right and left margins are set to the second. If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the third. If there are four values, they apply to the top, right, bottom, and left, respectively.e.g.
            <pre class="highlight">
"5px"                // all margins set to 5px
"5px 10px"           // top &amp; bottom = 5px, right &amp; left = 10px
"-10px 5px 8px"      // top = -10px, right &amp; left = 5px, bottom = 8px
"-10px -5px 5px 8px" // top = -10px, right = -5px, bottom = 5px, left = 8px
            </pre>
          </p>
        </dd>
        <dt>DOMString threshold = "1px"</dt>
        <dd>Threshold at which to trigger _callback_. _callback_ will be invoked when intersectionRect's area changes from greater than or equal to _threshold_ to less than _threshold_, and vice versa.<br /> This is a <a href="http://www.w3.org/TR/css3-values/#lengths">length</a> value.</dd>
      </dl>
    </section>
  </section>

  <section>
    <h2><dfn>Processing Model</dfn></h2>
    <p> This section outlines the steps the user agent MUST take when implementing <a>Intersection Observer</a>.</p>

    <section>
      <h2>Defines</h2>
      <section>
        <h3>_Document_ has:</h3>
        <ol>
          <li>Let <dfn>pendingCallbacks</dfn> be a list of <a>IntersectionObserver</a>s which have non-empty <a>queuedEntries</a> lists.</li>
          <li>Let <dfn>RegisteredIntersectionObserversForDocument</dfn> be a list of <a>registered Intersection Observer</a>s</li>
        </ol>
      </section>
      <section>
        <h3>_Element_ has:</h3>
        <ol>
          <li>Let <dfn>registeredObservers</dfn> be a list of <a>registered Intersection Observer</a>s.</li>
          <li>Let <dfn>previousIntersectionRect</dfn> be a <a href="http://www.w3.org/TR/2014/WD-geometry-1-20140522/#DOMRect">DOMRect</a> initially set to null.</li>
        </ol>
      </section>
      <section>
        <h3>_IntersectionObserver_ has:</h3>
        <ol>
          <li>Let <dfn>queuedEntries</dfn> be a list of <a>IntersectionObserverEntry</a> objects.</li>
          <li>Let <dfn>observationTargets</dfn> be a list of <a href="http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Element.html">Element</a>s.</li>
          <li>Let <dfn>init</dfn> be an <a>IntersectionObserverInit</a> object.</li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Algorithms</h2>
      <section>
        <h3><dfn>Queue an IntersectionObserverCallback</dfn></h3>
        <p>To <a>queue an IntersectionObserverCallback</a> for _observer_, run these steps:
          <ol>
            <li>If _Document_.<a>pendingCallbacks</a> contains _observer_, return.</li>
            <li>Append _observer_ to _Document_.<a>pendingCallbacks</a>.</li>
            <li>Post a task to <a>invoke an IntersectionObserverCallback</a>, or enqueue a task to <a>invoke an IntersectionObserverCallback</a> in <i>Document</i>'s <a href="https://w3c.github.io/requestidlecallback/#dfn-list-of-idle-request-callbacks">list of idle request callbacks</a> with an appropriate _timeout_.
              <pre class="issue">Should we define an appropriate _timeout_?</pre>
            </li>
          </ol>
        </p>
      </section>

      <section>
        <h3><dfn>Invoke an IntersectionObserverCallback</dfn></h3>
        <p>To <a>invoke an IntersectionObserverCallback</a> for _observer_, run these steps:
          <ol>
            <li>If _observer_.<a>queuedEntries</a> is empty, return.</li>
            <li>Construct an <a>IntersectionObserverEntryList</a> from _observer_.<a>queuedEntries</a>.</li>
            <li>Clear _observer_.<a>queuedEntries</a>.</li>
            <li>Remove _observer_ from <i>Document</i>.<a>pendingCallbacks</a>.</li>
            <li>Invoke _callback_ with the <a>IntersectionObserverEntryList</a> as the first argument and _observer_ as the second argument.</li>
          </ol>
        </p>
      </section>

      <section>
        <h3><dfn>Queue an IntersectionObserverEntry</dfn></h3>
        <p>To <a>queue an IntersectionObserverEntry</a> for _observer_, run these steps:
          <ol>
            <li>Construct an <a>IntersectionObserverEntry</a>.</li>
            <li>Append it to _observer_.<a>queuedEntries</a>.</li>
            <li><a>Queue an IntersectionObserverCallback</a> for _observer_.</li>
          </ol>
        </p>
      </section>
    </section>
    <section>
      <h2>Event Loop</h2>
      <p>An <a>Intersection Observer</a> processing step should take place AFTER the layout and rendering steps have been performed in the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#processing-model-8">update the rendering</a> event loop in the HTML Processing Model.</p>
      <p>This step is:</p>
      <ol start="11">
        <li>For each fully active _Document_ in _docs_
          <ul>
            <li>for each _observer_ in _Document_.<a>registeredIntersectionObserversForDocument</a></li>
            <ul>
              <li>for each _target_ in _observer_.<a>observationTargets</a></li>
              <ol>
                <li>compute an _intersectionRect_ which is the intersection of _target.getBoundingClientRect()_ with the bounds of _root_, adjusted by _observer_.<a>init</a>.<a href="#widl-IntersectionObserverInit-rootMargin" class="internalDFN">rootMargin</a>, intersected with the clip rect of each ancestor between _target_ and _observer_.<a>init</a>.<a href="#widl-IntersectionObserverInit-root" class="internalDFN">root</a>.
                  <ul>
                    <li>if <i>intersectionRect</i>'s area is greater than or equal to _observer_.<a>init</a>.<a href="#widl-IntersectionObserverInit-threshold" class="internalDFN">threshold</a> and target.<a>previousIntersectionRect</a> had an area that was less than the _threshold_, <a>queue an IntersectionObserverEntry</a>.</li>
                    <li>else if that <i>intersectionRect</i>'s area is less than _observer_.<a>init</a>.<a href="#widl-IntersectionObserverInit-threshold" class="internalDFN">threshold</a> and _target.<a>previousIntersectionRect</a> had an area that was greater or equal to the _threshold_, <a>queue an IntersectionObserverEntry</a>.</li>
                  </ul>
                  <pre class="issue"> TBD: Does _clipRect_ include <a href="http://www.w3.org/TR/2014/WD-css-masking-1-20140213/#the-clip-path">clip path</a> and other clipping properties or just overflow clipping?</pre></dd>
                </li>
                <li>record _intersctionRect_ as _target_.<a>previousIntersectionRect</a></li>
              </ol>
            </ul>
          </ul>
        </li>
      </ol>
    </section>
  </section>

</body>
</html>
